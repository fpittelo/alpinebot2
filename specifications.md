# Technical Specifications

## 1. Executive Summary

AlpineBot.ch is a minimalist, AI-powered platform providing up-to-date information about Switzerland. It features a public-facing portal, a secure chat interface, and an administrative backend. The system utilizes RAG (Retrieval-Augmented Generation) to ground AI responses in specific Swiss data.

**Target Architecture:** Cloud-Native PaaS on Azure (Switzerland North).

**Compliance:** Swiss FADP (nLPD) / GDPR alignment via strictly local hosting and privacy-first design.

## 2. Solution Architecture

### 2.1 Component Diagram (Logical)

```mermaid
graph TD
    User[Public User] -->|HTTPS| CDN[Azure Front Door / CDN]
    CDN -->|Static Content| WebApp[Azure App Service (Frontend)]
    WebApp -->|API Calls| Func[Azure Functions (Backend API)]

    subgraph "Azure Switzerland North"
        Func -->|Identity| KV[Azure Key Vault]
        Func -->|Vector Search & Data| DB[Azure Postgres Flexible (pgvector)]
        Func -->|Caching| Redis[Azure Cache for Redis]
        Func -->|Completion| OpenAI[Azure OpenAI (GPT-4o)]
        Admin[Admin User] -->|HTTPS| WebApp
    end

    GitHub[GitHub Actions] -->|Deploy| WebApp
    GitHub -->|Deploy| Func
    GitHub -->|Terraform| AzureRes[Azure Resources]
```

## 3. Technology Stack

### 3.1 Frontend (Presentation Layer)

- **Framework:** React (Vite) or Next.js (Static Export preferred for cost/performance).
- **Hosting:** Azure App Service (Linux Plan).
- **Styling:** Tailwind CSS (Minimalist/Swiss design principles).
- **State Management:** React Query (TanStack Query) for API interactions.
- **Authentication:** NextAuth.js or custom implementation wrapping Google OAuth 2.0.

### 3.2 Backend (Logic & AI Layer)

- **Runtime:** Python 3.11+ (Azure Functions V4).
- **Framework:** Azure Functions Programming Model v2.
- **Orchestration:** LangChain or Semantic Kernel for RAG flows.

### 3.3 Data & Storage

- **Primary Database:** Azure Database for PostgreSQL - Flexible Server.
  - **SKU:** Burstable B1ms (Cheapest instance, ~1 vCore, 2GB RAM).
  - **Extension:** pgvector (Enables vector similarity search within Postgres, removing need for Azure AI Search).
- **Caching:** Azure Cache for Redis (Basic C0 Tier).
- **Secrets:** Azure Key Vault (Standard).

## 4. Security & Secret Management Strategy

### 4.1 Authentication

- **Public/Admin:** Google OAuth 2.0.
- **Session Handling:** JWT stored in HttpOnly cookies (managed by Backend/NextAuth).

### 4.2 Dynamic Secret Management (The "Zero-Secret" Codebase)

To solve the issue of managing dynamic secrets between Web App, Functions, and OpenAI, we will use **Azure Managed Identities**.

1.  **Identity:** The Azure Function App and Web App are assigned a **System Assigned Managed Identity**.
2.  **Access Policies:**
    - Terraform grants the Function App Identity Key Vault Secret User role on the Key Vault.
    - Terraform grants the Function App Identity Cognitive Services User role on Azure OpenAI.
3.  **Runtime:** The application code uses `DefaultAzureCredential` (from `azure-identity` library). It automatically authenticates against resources without needing connection strings in environment variables.
4.  **GitHub Secrets:** The _only_ secrets stored in GitHub are the `AZURE_CLIENT_ID`, `SUBSCRIPTION_ID`, etc., needed for the OIDC login to run Terraform. The actual application secrets (DB passwords, API keys) are generated by Terraform and injected directly into Key Vault, never touching the GitHub runner.

## 5. Data & AI Architecture

### 5.1 Ingestion Pipeline

- **Trigger:** Weekly Timer Trigger (Azure Function).
- **Sources:**
  - [https://opendata.swiss/en](https://opendata.swiss/en)
  - [https://data.opentransportdata.swiss/en/dataset/](https://data.opentransportdata.swiss/en/dataset/)
- **Process:** Fetch Data -> Chunk Text -> Generate Embeddings (Azure OpenAI) -> Store in Postgres (pgvector).

### 5.2 Vector Store Optimization

- **Strategy:** Use pgvector on the B1ms Postgres instance to remain cost-effective.
- **Indexing:** Implement HNSW (Hierarchical Navigable Small World) indexing to ensure low-latency vector search performance on low-memory hardware.

## 6. DevOps & Environment Strategy

### 6.1 IaC & CI/CD

- **IaC:** Terraform (State stored in Azure Storage Account).
- **CI/CD:** GitHub Actions.
- **Repository Strategy:** Monorepo (Frontend/Backend/Infra in one repo).

### 6.2 Environments

Three strictly isolated environments:

| Feature                | Dev                 | QA                  | Main (Prod)                   |
| :--------------------- | :------------------ | :------------------ | :---------------------------- |
| **Branch**             | `dev`               | `qa`                | `main`                        |
| **Trigger**            | Push to `dev`       | Manual Dispatch     | Manual Dispatch (Release Tag) |
| **App Resource Group** | `dev-alpinebot`     | `qa-alpinebot`      | `main-alpinebot`              |
| **TF Backend RG**      | `dev-bkd-alpinebot` | `qa-bkd-alpinebot`  | `main-bkd-alpinebot`          |
| **Data**               | Mock/Synthetic      | Anonymized Snapshot | Real Data                     |

## 7. Monitoring & Operations

### 7.1 Observability

- **Tool:** Azure Application Insights.
- **Key Metrics:** AI Token usage costs, Chat latency, Error rates.

### 7.2 Health Checks

- **Requirement:** Web service app must have a simple `/health` endpoint checked every 5 minutes to ensure uptime.
